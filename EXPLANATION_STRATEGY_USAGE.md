# Strategy для использования предметов - Объяснение

## Вопрос: Будет ли правильным использовать Strategy для использования предметов?

**Короткий ответ:** Да, но не всегда. Strategy полезен, когда **один предмет может использоваться по-разному** в зависимости от контекста или выбора игрока.

## Когда Strategy ПРАВИЛЬНО использовать:

### 1. **Один предмет - разные способы использования**

**Пример:**
- **Зелье здоровья** можно:
  - Выпить (восстановить здоровье) - `ConsumeUsageStrategy`
  - Бросить во врага (нанести урон) - `ThrowUsageStrategy`
  - Использовать в крафте (создать лучшее зелье) - `CraftUsageStrategy`

**Преимущества:**
- Гибкость: игрок выбирает, как использовать предмет
- Расширяемость: легко добавить новый способ использования
- Соответствует OCP: не нужно менять класс `Potion`, чтобы добавить новый способ использования

### 2. **Разные контексты использования**

**Пример:**
- **В бою:** зелье восстанавливает 70% от обычного эффекта, но быстрее
- **Вне боя:** зелье восстанавливает 120% от обычного эффекта, но медленнее

**Реализация:** `ContextualUsageStrategy` с параметром `isInCombat`

### 3. **Динамическое изменение поведения**

**Пример:**
- В зависимости от навыков персонажа предметы работают по-разному
- В зависимости от уровня персонажа предметы дают разные эффекты

## Когда ТЕКУЩИЙ ПОДХОД (интерфейсы) ЛУЧШЕ:

### 1. **Каждый предмет имеет один способ использования**

**Примеры:**
- **Еда** всегда съедается (восстанавливает здоровье)
- **Оружие** всегда экипируется
- **Квестовый предмет** нельзя использовать

**Почему интерфейсы лучше:**
- Проще и понятнее
- Меньше кода
- Предмет сам знает, как его использовать (инкапсуляция)

### 2. **Поведение зависит от типа предмета, а не от контекста**

**Пример:**
- `Potion.Use()` всегда восстанавливает здоровье
- `Weapon.Equip()` всегда экипирует оружие

**Почему интерфейсы лучше:**
- Поведение зашито в класс предмета
- Не нужно передавать стратегию каждый раз
- Меньше сложности

## Гибридный подход (РЕКОМЕНДУЕТСЯ):

### Комбинируем оба подхода:

1. **Базовое поведение через интерфейсы:**
   - `IUsable` - для предметов, которые можно использовать
   - `IEquippable` - для предметов, которые можно экипировать

2. **Дополнительные способы через Strategy:**
   - Если предмет может использоваться по-разному, используем Strategy
   - Если предмет имеет один способ использования, используем интерфейс

### Пример использования:

```csharp
var usageService = new ItemUsageService(inventory);

// Стандартное использование через интерфейс
var result1 = usageService.UseItem(potion.Id); // Выпивает зелье

// Использование через Strategy (бросить зелье)
var throwStrategy = new ThrowUsageStrategy();
var result2 = usageService.UseItem(potion.Id, throwStrategy); // Бросает зелье

// Использование в зависимости от контекста
var combatStrategy = new ContextualUsageStrategy(isInCombat: true);
var result3 = usageService.UseItem(potion.Id, combatStrategy); // Использует в бою
```

## Выводы:

1. **Strategy полезен**, когда:
   - Один предмет может использоваться по-разному
   - Поведение зависит от контекста (в бою/вне боя)
   - Нужна гибкость в изменении поведения во время выполнения

2. **Интерфейсы лучше**, когда:
   - Каждый предмет имеет один четко определенный способ использования
   - Поведение зависит от типа предмета, а не от контекста
   - Нужна простота и понятность

3. **Гибридный подход** - лучший вариант:
   - Используем интерфейсы для базового поведения
   - Используем Strategy для дополнительных способов использования
   - Это дает гибкость без излишней сложности

## В нашем проекте:

Я добавил поддержку Strategy в `ItemUsageService`, но оставил возможность использовать стандартное поведение через интерфейсы. Это позволяет:

- Использовать предметы стандартным способом (через интерфейсы)
- Использовать предметы альтернативными способами (через Strategy)
- Легко добавлять новые способы использования без изменения существующего кода

Это соответствует принципам SOLID и делает систему более гибкой и расширяемой.
