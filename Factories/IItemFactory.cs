using InventorySystem.Core.Interfaces;

namespace InventorySystem.Factories;

/// <summary>
/// Паттерн ABSTRACT FACTORY - предоставляет интерфейс для создания семейств связанных объектов
/// без указания их конкретных классов.
/// 
/// ПРОБЛЕМА, которую решает Abstract Factory:
/// Нужно создавать разные типы предметов (оружие, броня, зелья и т.д.), но мы не хотим
/// зависеть от конкретных классов. Также может быть несколько "семейств" фабрик:
/// например, фабрика для обычных предметов и фабрика для легендарных предметов.
/// 
/// РЕШЕНИЕ:
/// Создаем абстрактный интерфейс IItemFactory с методами для создания каждого типа предмета.
/// Конкретные фабрики реализуют эти методы, создавая предметы определенного типа или стиля.
/// 
/// ПРИМЕР ИЗ РЕАЛЬНОЙ ЖИЗНИ:
/// Производство мебели: есть абстрактная фабрика "Мебель", которая создает стулья, столы, шкафы.
/// Конкретные фабрики: "Викторианская мебель" (создает викторианские стулья, столы, шкафы)
/// и "Современная мебель" (создает современные стулья, столы, шкафы). Клиент работает
/// с абстрактной фабрикой и получает согласованный стиль мебели.
/// 
/// В НАШЕМ СЛУЧАЕ:
/// У нас есть фабрики для каждого типа предмета (WeaponFactory, ArmorFactory и т.д.).
/// Это упрощенная версия Abstract Factory, но она демонстрирует принцип Dependency Inversion:
/// код зависит от абстракции (IItemFactory), а не от конкретных классов.
/// </summary>
public interface IItemFactory
{
    /// <summary>
    /// Создать предмет определенного типа
    /// </summary>
    IItem CreateItem(string name);
}
